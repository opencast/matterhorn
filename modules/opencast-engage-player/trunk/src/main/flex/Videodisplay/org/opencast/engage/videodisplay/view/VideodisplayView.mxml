<?xml version="1.0" encoding="utf-8"?>
<!--
	/**
	 *  Copyright 2009 The Regents of the University of California
	 *  Licensed under the Educational Community License, Version 2.0
	 *  (the "License"); you may not use this file except in compliance
	 *  with the License. You may obtain a copy of the License at
	 *
	 *  http://www.osedu.org/licenses/ECL-2.0
	 *
	 *  Unless required by applicable law or agreed to in writing,
	 *  software distributed under the License is distributed on an "AS IS"
	 *  BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
	 *  or implied. See the License for the specific language governing
	 *  permissions and limitations under the License.
	 *
	 */
	 -->
<mx:Canvas width="100%"
	height="100%"
	xmlns:players="com.adobe.strobe.players.*"
	xmlns:mx="http://www.adobe.com/2006/mxml"
	xmlns:view="org.opencast.engage.videodisplay.view.*"
	resize="{ resizeVideodisplay() }"
	>
	
	<mx:Script>
		<![CDATA[
			import org.osmf.events.MediaErrorEvent;
			import mx.messaging.messages.ErrorMessage;
			import org.osmf.utils.FMSURL;
			import org.osmf.composition.SerialElement;
			import mx.utils.LoaderUtil;
			import org.osmf.traits.LoadTrait;
			import org.osmf.media.LoadableMediaElement;
			import org.osmf.traits.ILoadedContext;
			import org.osmf.traits.LoadState;
			import org.osmf.events.LoaderEvent;
			import org.osmf.traits.ILoader;
			import org.osmf.traits.MediaTraitType;
			import org.osmf.audio.SoundLoader;
			import org.osmf.audio.AudioElement;
			import org.osmf.media.MediaElement;
			import org.osmf.utils.URL;
			import org.osmf.media.URLResource;
			import org.osmf.net.NetLoader;
			import org.osmf.video.VideoElement;
			import org.osmf.events.LoadEvent;
			import org.osmf.display.ScaleMode;
			import org.osmf.events.AudioEvent;
			import org.osmf.events.TimeEvent;
			import org.opencast.engage.videodisplay.state.MediaState;
			import org.opencast.engage.videodisplay.state.PlayerState;
            import bridge.ExternalFunction;
			import org.opencast.engage.videodisplay.control.event.ResizeVideodisplayEvent;
			import org.opencast.engage.videodisplay.control.event.DisplayCaptionEvent;
			import org.opencast.engage.videodisplay.control.event.LoadDFXPXMLEvent;
		    import org.swizframework.Swiz;
		  	import org.opencast.engage.videodisplay.control.event.VideoControlEvent;
			import org.opencast.engage.videodisplay.control.util.TimeCode;
			import org.opencast.engage.videodisplay.model.VideodisplayModel;
			import org.osmf.net.NetLoadedContext;
			import mx.core.Application;
			import mx.events.FlexEvent;
			import mx.controls.Alert;
			
            [Autowire]
			[Bindable]
			public var model:VideodisplayModel;
			
			private var mediaElement:MediaElement;
			private var _time:TimeCode;
			private var captionURL:String;
			private var mediaURL:String;
			private const TIMER_INTERVAL_BYTES_LOADED:int = 250;
            private var bytesLoadedTimer:Timer;        
			private var lastNewPositionString:String = "00:00:00";
			private var currentDurationString:String = "00:00:00";
			private var bytesLoaded:Number = 0;
			private var bytesTotal:Number = 0;	
			private var res:URLRequest;
			
			/** 
			 * initPlayer
			 * 
			 * Init the Videoplayer.
			 * 
			 *  */
			public function initPlayer():void
			{
				model.player = this.wrapper.mediaPlayer;
				_time = new TimeCode();
				
				bytesLoadedTimer = new Timer(TIMER_INTERVAL_BYTES_LOADED);    
                bytesLoadedTimer.addEventListener(TimerEvent.TIMER, progress);
                bytesLoadedTimer.start();
                
				// When the flash vars video_url ist not undifined
				if(Application.application.parameters.video_url != undefined)
			    {
					mediaURL = Application.application.parameters.video_url;
					
					var pos:int = mediaURL.lastIndexOf(".");
                    var fileType:String = mediaURL.substring(pos+1);
                
                    switch(fileType) 
                    {
                        case "flv": mediaElement = new VideoElement(new NetLoader(), new URLResource(new URL(mediaURL)));
	                                ExternalInterface.call(ExternalFunction.SETVOLUME, 100);
	                                model.mediaState = MediaState.VIDEO;
	                                break;
	                                
	                    case "mp4": mediaElement = new VideoElement(new NetLoader(), new URLResource(new URL(mediaURL)));
                                    ExternalInterface.call(ExternalFunction.SETVOLUME, 100);
                                    model.mediaState = MediaState.VIDEO;
                                    break;
	                    
	                    case "mp3": mediaElement =  new AudioElement(new SoundLoader(), new URLResource(new URL(mediaURL)));
	                                ExternalInterface.call(ExternalFunction.SETVOLUME, 100);
	                                model.mediaState = MediaState.AUDIO;
	                                var position:int = mediaURL.lastIndexOf('/');
	                                model.audioURL  = mediaURL.substring(position+1);                             
	                                break;
	                    
	                    default:    errorMessage("Error", "TRACK COULD NOT BE FOUND"); 
	                                break;
                    }
				}
				else
			    {
				    errorMessage("Error","TRACK COULD NOT BE FOUND");
			    }
			    
			    // When the flash vars captions ist not undifined
			    if(Application.application.parameters.captions != undefined)
		        {
		      		captionURL = Application.application.parameters.captions;
		        }
		      	
		      	// When the flash vars autoplay ist not undifined
		    	if(Application.application.parameters.autoplay != undefined)
		    	{
          	        if( Application.application.parameters.autoplay == "true" )
          	        {
          	        	model.player.autoPlay = true;
          	        	model.currentPlayerState = PlayerState.PLAYING;
                        ExternalInterface.call(ExternalFunction.SETPLAYPAUSESTATE, PlayerState.PAUSING);
                    }
          	        else
          	        {
          	           model.player.autoPlay = true;
          	           model.player.volume = 0.0;
                       wrapper.visible = false;
                    }
          	    }
	            else
	            {
	               model.player.autoPlay = true;
                   model.player.volume = 0.0;
                   wrapper.visible = false;
                }
	          
		      	if( captionURL != null )
		      	{
		      		// Load the DFXP	
		      		Swiz.dispatchEvent( new LoadDFXPXMLEvent( captionURL ) );
		      	}
		      	
		      	// Set up the MediaPlayer.
                model.player.autoRewind = true;
                
                wrapper.scaleMode = ScaleMode.LETTERBOX;
				wrapper.addEventListener(TimeEvent.DURATION_CHANGE, onDurationChange);		
				wrapper.addEventListener(AudioEvent.VOLUME_CHANGE, volumeChange );
				wrapper.addEventListener(LoadEvent.BYTES_TOTAL_CHANGE, onBytesTotalChange);
                wrapper.addEventListener(LoadEvent.BYTES_LOADED_CHANGE, onBytesLoadedChange);
                wrapper.addEventListener(TimeEvent.CURRENT_TIME_CHANGE, onCurrentTimeChange);
                wrapper.addEventListener(TimeEvent.DURATION_REACHED, onDurationReached);
                wrapper.addEventListener(MediaErrorEvent.MEDIA_ERROR, onMediaError);
                
                wrapper.element = mediaElement;
            }
			
			/**  
             * autoPlayOff
             * 
             * Stop the video at the beginning.
             * 
             * */
			private function autoPlayOff(): void 
			{
                Swiz.dispatchEvent( new VideoControlEvent(VideoControlEvent.STOP));
                wrapper.mediaPlayer.volume = 1.0;
                wrapper.visible = true;
            }
			
			/**  
			 * onDurationChange
			 * 
			 * @eventType event:TimeEvent
			 * 
			 * */
			private function onDurationChange(event:TimeEvent):void
			{	
				// Store new duration as current duration in the videodisplay model
				model.currentDuration = event.time;
				currentDurationString = _time.getTC(model.currentDuration);
				ExternalInterface.call(ExternalFunction.SETDURATION, event.time);
		    	ExternalInterface.call(ExternalFunction.SETTOTALTIME, currentDurationString);
		    	autoPlayOff();
		    }
			
			/** 
             * onCurrentTimeChange
             * 
             * @eventType event:TimeEvent
             * 
             * */
            private function onCurrentTimeChange(event:TimeEvent):void
            {   
              
                var newPositionString:String = _time.getTC(event.time);
                
                if(newPositionString != lastNewPositionString)
                {
                    ExternalInterface.call(ExternalFunction.SETCURRENTTIME, newPositionString);
                    lastNewPositionString = newPositionString;
                }
                
                if(!model.player.seeking)
                {
                  ExternalInterface.call(ExternalFunction.SETPLAYHEAD, event.time);
                }
                
                if( captionURL != null )
                {
                    Swiz.dispatchEvent( new DisplayCaptionEvent( event.time ) );
                }
                
                model.currentPlayhead = event.time;
              
            }
            
            /** 
             * onDurationReached
             * 
             * @eventType event:TimeEvent
             * 
             * */
            
            private function onDurationReached(event:TimeEvent):void
            {
             	model.player.pause();
             	model.currentPlayerState = PlayerState.PAUSING;
                ExternalInterface.call(ExternalFunction.SETPLAYPAUSESTATE, PlayerState.PLAYING);
            }
            
            /** 
             * onBytesTotalChange
             * 
             * @eventType event:LoadEvent
             * 
             * */
			private function onBytesTotalChange(event:LoadEvent):void
            {
                bytesTotal = event.bytes;
            }
        
            /** 
             * onBytesLoadedChange
             * 
             * @eventType event:LoadEvent
             * 
             * */
            private function onBytesLoadedChange(event:LoadEvent):void
            {
                bytesLoaded = event.bytes;
            }
			
			/** 
			 * progress
			 * 
			 * @eventType event:TimerEvent
			 * 
			 * */
			private function progress(event:TimerEvent):void
			{
	           if(model.mediaState == MediaState.VIDEO)
	           {
	               var loadableVideo: LoadTrait = mediaElement.getTrait(MediaTraitType.LOAD) as LoadTrait;
	               if (loadableVideo) 
	               {
	                   var context:NetLoadedContext = NetLoadedContext(loadableVideo.loadedContext);
	                   var progressVideo:Number = 0;
	                    
	                   try 
	                   {
	                       progressVideo = Math.round( context.stream.bytesLoaded / context.stream.bytesTotal * 100 );
		                   ExternalInterface.call(ExternalFunction.SETPROGRESS, progressVideo);
	                       model.progressBar.setProgress( progressVideo, 100);
	                   } 
	                   catch (e:TypeError)
	                   {
                            // ignore
                       }
	                    
	                   if( progressVideo >= 100 )
	                   {
	                      bytesLoadedTimer.stop();
	                   }
	               } 
	           }
	           else
	           {
	               var loadableAudio: LoadTrait = mediaElement.getTrait(MediaTraitType.LOAD) as LoadTrait;
	           
                   if (loadableAudio) 
                   {
                       var audioProgress:Number = 0;
                        
                       try 
                       {
                           audioProgress = Math.round( loadableAudio.bytesLoaded / loadableAudio.bytesTotal * 100 );
                           ExternalInterface.call(ExternalFunction.SETPROGRESS, audioProgress);
                           model.progressBar.setProgress( audioProgress, 100);
                       } 
                       catch (e:TypeError)
                       {
                           // ignore
                       }
                       
                       if( audioProgress >= 100 )
                       {
                           bytesLoadedTimer.stop();
                         
                       }
                   } 
	           }
	        }

			/**
			 * resizeVideodisplay
			 * 
			 * When the learner resize the Videodisplay in the Browser
			 * 
			 * */
			public function resizeVideodisplay():void
			{
				Swiz.dispatchEvent( new ResizeVideodisplayEvent() );
			}
			
			/**
			 * volumeChange
			 * 
			 * When the volume is change in the video
			 * 
			 * */
			private function volumeChange(event:AudioEvent):void
			{
				ExternalInterface.call(ExternalFunction.SETVOLUME, event.volume * 100);
				model.videoVolume = event.volume;
			}
			
			/**
             * onMediaError
             * 
             * When the media file ist nocht available.
             * 
             * */
			private function onMediaError( event:MediaErrorEvent ):void
            {
                model.error = new Error();
                model.error.name = event.error.description;
                model.error.message = event.error.detail;
            }
			
			/**
             * errorMessage
             * 
             * Set the error Message and switch the stage.
             * 
             * */
            private function errorMessage( name:String, message:String ):void
            {
                model.error = new Error();
                model.error.name = name;
                model.error.message = message;
                model.mediaState = MediaState.ERROR;
            }
        ]]>
	</mx:Script>
	
	<players:MediaPlayerWrapper 
		id="wrapper"
		width="100%"
		height="100%"
		addedToStage="initPlayer()"
		/>
		
</mx:Canvas>