<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<ns2:search-results xmlns:ns2="http://search.opencastproject.org/" total="1" limit="1" offset="0"><ns2:result id="algorithmen09_2010_1_19_13_51__131_173_10_32"><ns2:dcTitle>Folge 24: Hashing</ns2:dcTitle><ns2:dcCreator>Prof. Dr. Oliver Vornberger</ns2:dcCreator><ns2:dcPublisher>Uni Osnabrück</ns2:dcPublisher><ns2:dcCreated>2010-01-19</ns2:dcCreated><ns2:dcAbstract>Hashfunktion, Kollision, Sondieren, offen + geschlossen, HashSet, HashMap</ns2:dcAbstract><ns2:mediapackage duration="4952906" id="algorithmen09_2010_1_19_13_51__131_173_10_32"><title>Folge 24: Hashing</title><series>algorithmen09</series><creators><creator>Prof. Dr. Oliver Vornberger</creator></creators><media><track type="presenter/engage"><tags><tag>engage</tag></tags><url>rtmp://freecom.serv.uni-osnabrueck.de/oflaDemo/algorithmen09_2010_1_19_13_51__131_173_10_32.flv</url><duration>4952906</duration></track></media></ns2:mediapackage><ns2:segments><ns2:mediaSegments index="1" duration="123700" time="0"><ns2:text>Oliver Vornberger    Christian Viergutz   Patrick Fox  Institut für Informatik  Fachbereich Mathematik/Informatik  Universität Osnabrück   Algorithmen   Vorlesung im WS 2009/2010   </ns2:text><ns2:title>Algorithmen</ns2:title><ns2:previews><ns2:preview type="presentation">http://video.lernfunk.de/lectures/algorithmen09/algorithmen09_2010_1_19_13_51__131_173_10_32/assets/thumbs/Thumb1.jpg</ns2:preview></ns2:previews></ns2:mediaSegments><ns2:mediaSegments index="2" duration="449400" time="123700"><ns2:text>Hashing Element int f mögliche Elemente N  Adressen </ns2:text><ns2:title>Hashing</ns2:title><ns2:previews><ns2:preview type="presentation">http://video.lernfunk.de/lectures/algorithmen09/algorithmen09_2010_1_19_13_51__131_173_10_32/assets/thumbs/Thumb2.jpg</ns2:preview></ns2:previews></ns2:mediaSegments><ns2:mediaSegments index="3" duration="255200" time="573100"><ns2:text>Offenes Hashing Fritz Emil Heinz Mark Carsten Achim Mark private Liste[] n; //Jedes Bucket enthält eine Liste von Comparables </ns2:text><ns2:title>Offenes Hashing</ns2:title><ns2:previews><ns2:preview type="presentation">http://video.lernfunk.de/lectures/algorithmen09/algorithmen09_2010_1_19_13_51__131_173_10_32/assets/thumbs/Thumb3.jpg</ns2:preview></ns2:previews></ns2:mediaSegments><ns2:mediaSegments index="4" duration="867900" time="828300"><ns2:text>Geschlossenes Hashing Fritz B Emil B L L Mark B L Carsten B G L Heinz B G L Eva B L L Achim B L 0 N-1 L = LEER B = BELEGT G = GELOESCHT public Comparable[] inhalt; private byte[] Zustand; Es wurden nacheinander Fritz, Mark, Emil, Carsten, Ulf, Heinz, Lutz, Eva, Achim eingefügt und anschließend Ulf, Lutz gelöscht.   Die Abbildung zeigt das Ergebnis bei geschlossenem Hashing mit quadratischem Sondieren als Kollisionsstrategie. Alternativen sind lineares Sondieren und Double Hashing </ns2:text><ns2:title>Geschlossenes Hashing</ns2:title><ns2:previews><ns2:preview type="presentation">http://video.lernfunk.de/lectures/algorithmen09/algorithmen09_2010_1_19_13_51__131_173_10_32/assets/thumbs/Thumb4.jpg</ns2:preview></ns2:previews></ns2:mediaSegments><ns2:mediaSegments index="5" duration="699800" time="1696200"><ns2:text>OfHashing public class OfHashing implements Menge {    private Liste[] b ;     public OfHashing(int N) {        b = new Liste[N];        for (int i=0; i&lt;N; i++)       b[i]=new VerweisListe();     }     public boolean empty() {        ...    }    public Comparable lookup(Comparable x) {        ...    }    public boolean insert(Comparable x) {        ...    }    public boolean delete(Comparable x) {        ...    } } </ns2:text><ns2:title>OfHashing</ns2:title><ns2:previews><ns2:preview type="presentation">http://video.lernfunk.de/lectures/algorithmen09/algorithmen09_2010_1_19_13_51__131_173_10_32/assets/thumbs/Thumb5.jpg</ns2:preview></ns2:previews></ns2:mediaSegments><ns2:mediaSegments index="6" duration="92900" time="2396000"><ns2:text>GeHashing public class GeHashing implements Menge {        private final static byte LEER = 0;     private final static byte BELEGT = 1;     private final static byte GELOESCHT = 2;     private Comparable[] inhalt;     private byte[] zustand;     public GeHashing(int N) {        inhalt = new Comparable[N];        zustand = new byte[N];       for (int i=0; i&lt;N; i++) zustand[i]=LEER;     }     public boolean empty() { ... }        public Comparable lookup(Comparable x) { ... }    public boolean insert(Comparable x) { ... }    public boolean delete(Comparable x) { ... }  } </ns2:text><ns2:title>GeHashing</ns2:title><ns2:previews><ns2:preview type="presentation">http://video.lernfunk.de/lectures/algorithmen09/algorithmen09_2010_1_19_13_51__131_173_10_32/assets/thumbs/Thumb6.jpg</ns2:preview></ns2:previews></ns2:mediaSegments><ns2:mediaSegments index="7" duration="2500" time="2488900"><ns2:text>Geschlossenes Hashing Fritz B Emil B L L Mark B L Carsten B G L Heinz B G L Eva B L L Achim B L 0 N-1 L = LEER B = BELEGT G = GELOESCHT public Comparable[] inhalt; private byte[] Zustand; Es wurden nacheinander Fritz, Mark, Emil, Carsten, Ulf, Heinz, Lutz, Eva, Achim eingefügt und anschließend Ulf, Lutz gelöscht.   Die Abbildung zeigt das Ergebnis bei geschlossenem Hashing mit quadratischem Sondieren als Kollisionsstrategie. Alternativen sind lineares Sondieren und Double Hashing </ns2:text><ns2:title>Geschlossenes Hashing</ns2:title><ns2:previews><ns2:preview type="presentation">http://video.lernfunk.de/lectures/algorithmen09/algorithmen09_2010_1_19_13_51__131_173_10_32/assets/thumbs/Thumb4.jpg</ns2:preview></ns2:previews></ns2:mediaSegments><ns2:mediaSegments index="8" duration="419700" time="2491400"><ns2:text>GeHashing public class GeHashing implements Menge {        private final static byte LEER = 0;     private final static byte BELEGT = 1;     private final static byte GELOESCHT = 2;     private Comparable[] inhalt;     private byte[] zustand;     public GeHashing(int N) {        inhalt = new Comparable[N];        zustand = new byte[N];       for (int i=0; i&lt;N; i++) zustand[i]=LEER;     }     public boolean empty() { ... }        public Comparable lookup(Comparable x) { ... }    public boolean insert(Comparable x) { ... }    public boolean delete(Comparable x) { ... }  } </ns2:text><ns2:title>GeHashing</ns2:title><ns2:previews><ns2:preview type="presentation">http://video.lernfunk.de/lectures/algorithmen09/algorithmen09_2010_1_19_13_51__131_173_10_32/assets/thumbs/Thumb6.jpg</ns2:preview></ns2:previews></ns2:mediaSegments><ns2:mediaSegments index="9" duration="1022600" time="2911100"><ns2:text>Laufzeit geschlossenes Hashing AVL-Baum  Geschlossenes Hashing Laufzeit  logarithmisch  konstant  Speicherbedarf  dynamisch wachsend  in Sprüngen wachsend  Sortierung  möglich durch Traversierung  nicht möglich  </ns2:text><ns2:title>Laufzeit geschlossenes Hashing</ns2:title><ns2:previews><ns2:preview type="presentation">http://video.lernfunk.de/lectures/algorithmen09/algorithmen09_2010_1_19_13_51__131_173_10_32/assets/thumbs/Thumb7.jpg</ns2:preview></ns2:previews></ns2:mediaSegments><ns2:mediaSegments index="10" duration="475400" time="3933700"><ns2:text>Collection - Framework Collection TreeSet Set SortedSet List LinkedList boolean  add(Object o);  boolean  contains(Object o);) boolean  remove(Object o);  boolean  isEmpty();  Iterator iterator();  boolean hasNext();  Object  next();   void    remove();   </ns2:text><ns2:title>Collection - Framework</ns2:title><ns2:previews><ns2:preview type="presentation">http://video.lernfunk.de/lectures/algorithmen09/algorithmen09_2010_1_19_13_51__131_173_10_32/assets/thumbs/Thumb8.jpg</ns2:preview></ns2:previews></ns2:mediaSegments><ns2:mediaSegments index="11" duration="543806" time="4409100"><ns2:text>Hashing in Java Map&lt;Integer, String&gt; h = new HashMap&lt;Integer, String&gt;(100); h.put(42,“Susi“);  if(h.containsKey(42))… if(h.containsValue(“Susi“))…  String s = h.get(42); h.remove();  Collection&lt;String&gt; c = h.values(); Iterator&lt;String&gt; iter = c.iterator(); while(iter.hasNext()){    s = iter.next();    IO.println(s); } </ns2:text><ns2:title>Hashing in Java</ns2:title><ns2:previews><ns2:preview type="presentation">http://video.lernfunk.de/lectures/algorithmen09/algorithmen09_2010_1_19_13_51__131_173_10_32/assets/thumbs/Thumb9.jpg</ns2:preview></ns2:previews></ns2:mediaSegments></ns2:segments><ns2:cover>http://video.lernfunk.de/lectures/algorithmen09/algorithmen09_2010_1_19_13_51__131_173_10_32/assets/thumbs/Thumb1.jpg</ns2:cover></ns2:result></ns2:search-results>