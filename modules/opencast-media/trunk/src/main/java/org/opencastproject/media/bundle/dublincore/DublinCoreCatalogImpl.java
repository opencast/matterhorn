/**
 *  Copyright 2009 The Regents of the University of California
 *  Licensed under the Educational Community License, Version 2.0
 *  (the "License"); you may not use this file except in compliance
 *  with the License. You may obtain a copy of the License at
 *
 *  http://www.osedu.org/licenses/ECL-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an "AS IS"
 *  BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 *  or implied. See the License for the specific language governing
 *  permissions and limitations under the License.
 *
 */
package org.opencastproject.media.bundle.dublincore;

import static org.opencastproject.util.Tool.cast;

import org.opencastproject.media.bundle.Bundle;
import org.opencastproject.media.bundle.DublinCoreCatalog;
import org.opencastproject.media.bundle.EName;
import org.opencastproject.media.bundle.XMLCatalog;
import org.opencastproject.util.UnknownFileTypeException;

import org.apache.commons.collections.Closure;
import org.apache.commons.collections.CollectionUtils;
import org.apache.commons.collections.Predicate;
import org.apache.commons.collections.Transformer;
import org.apache.commons.lang.StringUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.xml.sax.Attributes;
import org.xml.sax.SAXException;
import org.xml.sax.SAXParseException;
import org.xml.sax.helpers.DefaultHandler;

import java.io.File;
import java.io.IOException;
import java.io.OutputStream;
import java.lang.reflect.Field;
import java.lang.reflect.Modifier;
import java.security.NoSuchAlgorithmException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import javax.xml.XMLConstants;
import javax.xml.parsers.ParserConfigurationException;
import javax.xml.parsers.SAXParser;
import javax.xml.parsers.SAXParserFactory;
import javax.xml.transform.TransformerException;

/**
 * Implements the dublin core metadata container.
 * 
 * @author Tobias Wunden <tobias.wunden@id.ethz.ch>
 * @author Christoph E. Driessen <ced@neopoly.de>
 * @version $Id$
 */
public class DublinCoreCatalogImpl extends XMLCatalog implements
    DublinCoreCatalog {

  /**
   * Serial version UID
   */
  private static final long serialVersionUID = -4240831568101931784L;

  /**
   * the logging facility provided by log4j
   */
  static final Logger log_ = LoggerFactory
      .getLogger(DublinCoreCatalogImpl.class);

  public static final String REPLAY_NS_URI = "http://ethz.ch/replay";
  public static final String REPLAY_NS_PREFIX = "replay";

  /**
   * Namespace name of Dublin Core metadata generated by REPLAY. By default this
   * namespace is the default namespace of XML documents generated by this
   * class.
   */
  public static final String REPLAY_DUBLIN_CORE_NS_URI = "http://www.replay.ethz.ch/xsd/1.0/dublincore/";

  public static final EName PROPERTY_PROMOTED = new EName(REPLAY_NS_URI,
      "promoted");
  public static final EName PROPERTY_ADVERTISED = new EName(REPLAY_NS_URI,
      "advertised");

  static final EName ROOT_ELEMENT = new EName(REPLAY_DUBLIN_CORE_NS_URI,
      "metadata");

  private static final Set<EName> PROPERTIES = new HashSet<EName>();

  // Build property set
  static {
    for (Field f : DublinCoreCatalogImpl.class.getFields()) {
      if (Modifier.isStatic(f.getModifiers())
          && EName.class.isAssignableFrom(f.getType())
          && f.getName().startsWith("PROPERTY_")) {
        try {
          PROPERTIES.add((EName) f.get(null));
        } catch (IllegalAccessException ignore) {
        }
      }
    }
  }

  /**
   * Creates a new dublin core metadata container from the specified file.
   * 
   * @param file
   *          the timeline file
   * @throws IOException
   *           if reading of the file fails
   * @throws UnknownFileTypeException
   *           if the file is of an unknown filetype
   * @throws NoSuchAlgorithmException
   *           if the md5 checksum cannot be computed
   */
  DublinCoreCatalogImpl(File file) throws IOException,
      UnknownFileTypeException, NoSuchAlgorithmException {
    super(DublinCoreCatalog.FLAVOR, file);
    // Namespace bindings
    bindings.bindPrefix(XMLConstants.DEFAULT_NS_PREFIX,
        REPLAY_DUBLIN_CORE_NS_URI);
    bindings.bindPrefix("dc", ELEMENTS_1_1_NS_URI);
    bindings.bindPrefix("dcterms", TERMS_NS_URI);
    bindings.bindPrefix("replay", REPLAY_NS_URI);
  }

  /**
   * Creates a new dublin core metadata container file at the specified location
   * for a bundle with the given identifier.
   * 
   * @return the new dublin core metadata container
   * @throws UnknownFileTypeException
   *           if the dublin core file type is unknown (very unlikely)
   * @throws IOException
   *           if creating the dublin core file fails
   * @throws TransformerException
   *           if saving the dublin core file fails
   * @throws ParserConfigurationException
   *           if creating the xml parser fails
   * @throws NoSuchAlgorithmException
   *           if the md5 checksum cannot be computed
   */
  static DublinCoreCatalog newInstance(Bundle bundle) throws IOException,
      UnknownFileTypeException, ParserConfigurationException,
      TransformerException, NoSuchAlgorithmException {
    DublinCoreCatalogImpl dc = new DublinCoreCatalogImpl(new File(bundle
        .getRoot(), DublinCoreCatalog.FILENAME));
    return dc;
  }

  /**
   * Creates a new dublin core metadata container file at the specified location
   * for a bundle with the given identifier.
   * 
   * @return the new dublin core metadata container
   * @throws IOException
   *           if creating the dublin core file fails
   * @throws UnknownFileTypeException
   *           if the dublin core file type is unknown (very unlikely)
   * @throws NoSuchAlgorithmException
   *           if the md5 checksum cannot be computed
   */
  public static DublinCoreCatalog newInstance() throws IOException,
      NoSuchAlgorithmException, UnknownFileTypeException {
    String[] name = DublinCoreCatalog.FILENAME.split("\\.");
    File file = File.createTempFile(name[0], "." + name[1]);
    DublinCoreCatalogImpl dc = new DublinCoreCatalogImpl(file);
    return dc;
  }

  /**
   * Reads the metadata from the specified file and returns it encapsulated in a
   * {@link DublinCoreCatalog} object.
   * 
   * @param catalog
   *          the dublin core metadata container file
   * @return the dublin core object
   * @throws IOException
   *           if reading the metadata fails
   * @throws UnknownFileTypeException
   *           if the dublin core file is of an unknown file type
   * @throws ParserConfigurationException
   *           if the dublin core parser cannot be created
   * @throws NoSuchAlgorithmException
   *           if the md5 checksum cannot be computed
   * @throws SAXException
   *           if reading the catalog fails
   */
  public static DublinCoreCatalog fromFile(File catalog) throws IOException,
      UnknownFileTypeException, ParserConfigurationException,
      NoSuchAlgorithmException, SAXException {
    DublinCoreParser parser = new DublinCoreParser();
    return parser.parse(catalog);
  }

  /**
   * Returns a text representation of the dublin core content. It is intended to
   * be used to easily search the catalog.
   * 
   * @return the text representation
   */
  public String toText() {
    StringBuffer buf = new StringBuffer();
    for (List<CatalogEntry> entriesByQName : data.values()) {
      for (CatalogEntry entry : entriesByQName) {
        if (buf.length() > 0)
          buf.append(" ");
        buf.append(entry.getValue());
      }
    }
    return buf.toString();
  }

  /**
   * @see java.lang.Object#toString()
   */
  @Override
  public String toString() {
    return "Dublin Core";
  }

  @Override
  public void bindPrefix(String prefix, String namespaceName) {
    super.bindPrefix(prefix, namespaceName);
  }

  public List<String> get(EName property, final String language) {
    if (property == null)
      throw new IllegalArgumentException("Property name must not be null");
    if (language == null)
      throw new IllegalArgumentException("Language code must not be null");

    if (LANGUAGE_ANY.equals(language)) {
      return cast(CollectionUtils.collect(getValuesAsList(property),
          new Transformer() {
            public Object transform(Object o) {
              return ((CatalogEntry) o).getValue();
            }
          }));
    } else {
      final List<String> values = new ArrayList<String>();
      final boolean langUndef = LANGUAGE_UNDEFINED.equals(language);
      CollectionUtils.forAllDo(getValuesAsList(property), new Closure() {
        public void execute(Object o) {
          String lang = ((CatalogEntry) o).getAttribute(XML_LANG_ATTR);
          if ((langUndef && lang == null) || (language.equals(lang)))
            values.add(lang);
        }
      });
      return values;
    }
  }

  public List<DublinCoreValue> get(EName property) {
    if (property == null)
      throw new IllegalArgumentException("Property name must not be null");

    return cast(CollectionUtils.collect(getValuesAsList(property),
        new org.apache.commons.collections.Transformer() {
          public Object transform(Object o) {
            CatalogEntry entry = (CatalogEntry) o;
            String lang = entry.getAttribute(XML_LANG_ATTR);
            return new DublinCoreValue(entry.getValue(), lang != null ? lang
                : LANGUAGE_UNDEFINED);
          }
        }));
  }

  public String getFirst(EName property, String language) {
    if (property == null)
      throw new IllegalArgumentException("Property name must not be null");
    if (language == null)
      throw new IllegalArgumentException("Language code must not be null");

    return _getFirst(property, language);
  }

  public String getFirst(EName property) {
    if (property == null)
      throw new IllegalArgumentException("Property name must not be null");

    return _getFirst(property, LANGUAGE_ANY);
  }

  private String _getFirst(EName property, String language) {
    CatalogEntry entry = null;
    if (LANGUAGE_UNDEFINED.equals(language)) {
      entry = getFirstLocalizedValue(property, null);
    } else if (LANGUAGE_ANY.equals(language)) {
      for (CatalogEntry value : getValuesAsList(property)) {
        entry = value;
        // Prefer values without language information
        if (!value.hasAttribute(XML_LANG_ATTR))
          break;
      }
    } else {
      entry = getFirstLocalizedValue(property, language);
    }
    return entry != null ? entry.getValue() : null;
  }

  public String getAsText(EName property, String language, String delimiter) {
    if (property == null)
      throw new IllegalArgumentException("Property name must not be null");
    if (language == null)
      throw new IllegalArgumentException("Language code must not be null");
    if (delimiter == null)
      delimiter = "";

    List<CatalogEntry> values;
    if (LANGUAGE_UNDEFINED.equals(language)) {
      values = getLocalizedValuesAsList(property, null);
    } else if (LANGUAGE_ANY.equals(language)) {
      values = getValuesAsList(property);
    } else {
      values = getLocalizedValuesAsList(property, language);
    }
    return values.size() > 0 ? StringUtils.join(CollectionUtils.collect(values,
        new Transformer() {
          public Object transform(Object o) {
            return ((CatalogEntry) o).getValue();
          }
        }), delimiter) : null;
  }

  public Set<String> getLanguages(EName property) {
    if (property == null)
      throw new IllegalArgumentException("Property name must not be null");

    Set<String> languages = new HashSet<String>();
    for (CatalogEntry entry : getValuesAsList(property)) {
      String language = entry.getAttribute(XML_LANG_ATTR);
      if (language != null)
        languages.add(language);
      else
        languages.add(LANGUAGE_UNDEFINED);
    }
    return languages;
  }

  public boolean hasMultipleValues(EName property, String language) {
    if (property == null)
      throw new IllegalArgumentException("Property name must not be null");
    if (language == null)
      throw new IllegalArgumentException("Language code must not be null");

    return _hasMultipleValues(property, language);
  }

  public boolean hasMultipleValues(EName property) {
    if (property == null)
      throw new IllegalArgumentException("Property name must not be null");

    return _hasMultipleValues(property, LANGUAGE_ANY);
  }

  private boolean _hasMultipleValues(EName property, String language) {
    if (LANGUAGE_ANY.equals(language)) {
      return getValuesAsList(property).size() > 1;
    } else {
      int counter = 0;
      for (CatalogEntry entry : getValuesAsList(property)) {
        if (equalLanguage(language, entry.getAttribute(XML_LANG_ATTR)))
          counter++;
        if (counter > 1)
          return true;
      }
      return false;
    }
  }

  public boolean hasValue(EName property, String language) {
    if (property == null)
      throw new IllegalArgumentException("Property name must not be null");
    if (language == null)
      throw new IllegalArgumentException("Language code must not be null");

    return _hasValue(property, language);
  }

  public boolean hasValue(EName property) {
    if (property == null)
      throw new IllegalArgumentException("Property name must not be null");

    return _hasValue(property, LANGUAGE_ANY);
  }

  private boolean _hasValue(EName property, final String language) {
    if (LANGUAGE_ANY.equals(language)) {
      return getValuesAsList(property).size() > 0;
    } else {
      return CollectionUtils.find(getValuesAsList(property), new Predicate() {
        public boolean evaluate(Object o) {
          return equalLanguage(((CatalogEntry) o).getAttribute(XML_LANG_ATTR),
              language);
        }
      }) != null;
    }
  }

  public void set(EName property, String value, String language) {
    if (property == null)
      throw new IllegalArgumentException("Property name must not be null");
    if (language == null || LANGUAGE_ANY.equals(language))
      throw new IllegalArgumentException(
          "Language code may not be null or LANGUAGE_ANY");

    _set(property, value, language, null);
  }

  public void set(EName property, String value) {
    if (property == null)
      throw new IllegalArgumentException("Property name must not be null");

    _set(property, value, LANGUAGE_UNDEFINED, null);
  }

  public void set(EName property, DublinCoreValue value) {
    if (property == null)
      throw new IllegalArgumentException("Property name must not be null");

    if (value != null) {
      _set(property, value.getValue(), value.getLanguage(), value
          .getEncodingScheme());
    } else {
      _remove(property, LANGUAGE_ANY);
    }
  }

  private void _set(EName property, String value, String language,
      EName encodingScheme) {
    if (value == null) {
      // No value, remove the whole element
      _remove(property, language);
    } else {
      String lang = !LANGUAGE_UNDEFINED.equals(language) ? language : null;
      removeLocalizedValues(property, lang);
      _add(property, value, language, encodingScheme);
    }
  }

  public void add(EName property, String value) {
    if (property == null)
      throw new IllegalArgumentException("Property name must not be null");
    if (value == null)
      throw new IllegalArgumentException("Value must not be null");

    _add(property, value, LANGUAGE_UNDEFINED, null);
  }

  public void add(EName property, String value, String language) {
    if (property == null)
      throw new IllegalArgumentException("Property name must not be null");
    if (value == null)
      throw new IllegalArgumentException("Value must not be null");
    if (language == null || LANGUAGE_ANY.equals(language))
      throw new IllegalArgumentException(
          "Language code may not be null or LANGUAGE_ANY");

    _add(property, value, language, null);
  }

  public void add(EName property, DublinCoreValue value) {
    if (property == null)
      throw new IllegalArgumentException("Property name must not be null");
    if (value == null)
      throw new IllegalArgumentException("Value must not be null");

    _add(property, value.getValue(), value.getLanguage(), value
        .getEncodingScheme());
  }

  private void _add(EName property, String value, String language,
      EName encodingScheme) {
    if (LANGUAGE_UNDEFINED.equals(language)) {
      if (encodingScheme == null) {
        addElement(property, value);
      } else {
        addTypedElement(property, value, encodingScheme);
      }
    } else {
      // Language defined
      if (encodingScheme == null) {
        addLocalizedElement(property, value, language);
      } else {
        addTypedLocalizedElement(property, value, language, encodingScheme);
      }
    }
  }

  public void remove(EName property, String language) {
    if (property == null)
      throw new IllegalArgumentException("Property name must not be null");
    if (language == null)
      throw new IllegalArgumentException("Language code must not be null");

    _remove(property, language);
  }

  public void remove(EName property) {
    if (property == null)
      throw new IllegalArgumentException("Property name must not be null");

    _remove(property, LANGUAGE_ANY);
  }

  private void _remove(EName property, String language) {
    if (LANGUAGE_ANY.equals(language)) {
      removeElement(property);
    } else if (LANGUAGE_UNDEFINED.equals(language)) {
      removeLocalizedValues(property, null);
    } else {
      removeLocalizedValues(property, language);
    }
  }

  @Override
  public void clear() {
    super.clear();
  }

  @Override
  public Object clone() throws CloneNotSupportedException {
    DublinCoreCatalogImpl clone = null;
    try {
      clone = (DublinCoreCatalogImpl) DublinCoreCatalogImpl.newInstance();
    } catch (Exception e) {
      throw new RuntimeException(e);
    }
    if (data instanceof HashMap)
      clone.data = (Map<EName, List<CatalogEntry>>) ((HashMap) data).clone();
    else
      throw new RuntimeException(
          "Bug: Cloning is currently only supported for HashMap based "
              + "XMLCatalog implementations");
    return clone;
  }

  public Set<EName> getProperties() {
    return PROPERTIES;
  }

  protected boolean equalLanguage(String a, String b) {
    return (a == null && b == LANGUAGE_UNDEFINED)
        || (a == LANGUAGE_UNDEFINED && b == null) || (a == LANGUAGE_ANY)
        || (b == LANGUAGE_ANY) || (a != null && a.equals(b));
  }

  /**
   * Saves the dublin core metadata container to disk.
   * 
   * @throws ParserConfigurationException
   *           if the xml parser environment is not correctly configured
   * @throws TransformerException
   *           if serialization of the metadata document fails
   * @throws IOException
   *           if an error with catalog file handling occurs
   */
  public void save() throws ParserConfigurationException, TransformerException,
      IOException {
    Document doc = createDocument();
    saveToXml(doc);
  }

  /**
   * Outputs the dublin core metadata container to the given output stream.
   * 
   * @param out
   *          the output stream
   * @throws ParserConfigurationException
   *           if the xml parser environment is not correctly configured
   * @throws TransformerException
   *           if serialization of the metadata document fails
   * @throws IOException
   *           if an error with catalog file handling occurs
   */
  public void save(OutputStream out) throws ParserConfigurationException,
      TransformerException, IOException {
    saveToXml(createDocument(), out);
  }

  /**
   * Create a DOM representation of the DublinCore.
   */
  private Document createDocument() throws ParserConfigurationException {
    // Create the DOM document
    Document doc = newDocument();
    Element rootElement = doc.createElementNS(ROOT_ELEMENT.getNamespaceName(),
        toQName(ROOT_ELEMENT));
    doc.appendChild(rootElement);
    // Add the elements
    for (EName property : PROPERTIES) {
      boolean required = property.equals(PROPERTY_TITLE);
      addElement(doc, rootElement, property, required);
    }
    return doc;
  }

  /**
   * Adds the dublin core property identified by <code>name</code> to the root
   * node if it's value is different from <code>null</code>.
   * 
   * @param document
   *          the document
   * @param root
   *          the root node
   * @param property
   *          the property name
   * @param required
   *          <code>true</code> if this property is required
   * @return <code>true</code> if the element was added
   * @throws IllegalStateException
   *           if a required property is missing
   */
  private boolean addElement(Document document, Element root, EName property,
      boolean required) throws IllegalStateException {
    CatalogEntry[] elements = getValues(property);
    boolean changed = false;
    if (elements.length > 0) {
      for (CatalogEntry element : elements) {
        changed |= (root.appendChild(element.toXml(document)) != null);
      }
      return changed;
    } else if (required) {
      throw new IllegalStateException("Required property '" + property
          + "' is missing");
    }
    return false;
  }

  /**
   * Class to parse a dublin core file.
   * 
   * @author Tobias Wunden <tobias.wunden@id.ethz.ch>
   */
  static class DublinCoreParser extends DefaultHandler {

    /**
     * The manifest
     */
    private DublinCoreCatalogImpl dcDoc = null;

    /**
     * The element content
     */
    private StringBuffer content = new StringBuffer();

    /**
     * The node attributes
     */
    private Attributes attributes = null;

    /**
     * Flag to check if this is not just an arbitrary xml document
     */
    private boolean isDublinCore = false;

    /**
     * Creates a new parser for dublin core files.
     */
    DublinCoreParser() {
    }

    /**
     * Parses the catalog file and returns its object representation.
     * 
     * @param file
     *          the file containing the dublin core catalog
     * @return the catalog representation
     * @throws javax.xml.parsers.ParserConfigurationException
     *           if setting up the parser failed
     * @throws org.xml.sax.SAXException
     *           if an error occured while parsing the document
     * @throws java.io.IOException
     *           if the file cannot be accessed in a proper way
     * @throws UnknownFileTypeException
     *           if the catalog file type is unknown
     * @throws java.security.NoSuchAlgorithmException
     *           if the checksum cannot be calculated
     * @throws IllegalArgumentException
     *           if the
     */
    public DublinCoreCatalogImpl parse(File file) throws SAXException,
        IOException, ParserConfigurationException, NoSuchAlgorithmException,
        UnknownFileTypeException {
      this.dcDoc = new DublinCoreCatalogImpl(file);
      SAXParserFactory factory = SAXParserFactory.newInstance();
      // REPLAY does not use a DTD here
      factory.setValidating(false);
      factory.setNamespaceAware(true);
      SAXParser parser = factory.newSAXParser();
      parser.parse(file, this);

      // Did we parse a dublin core document?
      if (!isDublinCore)
        throw new IllegalArgumentException(file + " is no dublin core document");

      return dcDoc;
    }

    @Override
    public void characters(char[] ch, int start, int length)
        throws SAXException {
      super.characters(ch, start, length);
      content.append(ch, start, length);
    }

    /**
     * Returns the element content.
     * 
     * @return the element content
     */
    private String getContent() {
      String str = content.toString().trim();
      content = new StringBuffer();
      return str;
    }

    /**
     * Read <code>type</code> attribute from track or catalog element.
     * 
     * @see org.xml.sax.helpers.DefaultHandler#startElement(String, String,
     *      String, org.xml.sax.Attributes)
     */
    @Override
    public void startElement(String uri, String localName, String name,
        Attributes attributes) throws SAXException {
      super.startElement(uri, localName, name, attributes);
      this.attributes = attributes;

      // Make sure this is a dublin core catalog
      // TODO: Improve this test, add namespace awareness
      if (!isDublinCore && ROOT_ELEMENT.getNamespaceName().equals(uri))
        isDublinCore = true;
    }

    @Override
    public void endElement(String uri, String localName, String name)
        throws SAXException {
      super.endElement(uri, localName, name);
      dcDoc.addElement(new EName(uri, localName), getContent(), attributes);
    }

    @Override
    public void error(SAXParseException e) throws SAXException {
      log_.warn("Error parsing dublincore catalog: " + e.getMessage());
      super.error(e);
    }

    @Override
    public void fatalError(SAXParseException e) throws SAXException {
      log_.warn("Fatal error parsing dublincore catalog: " + e.getMessage());
      super.fatalError(e);
    }

    @Override
    public void warning(SAXParseException e) throws SAXException {
      log_.warn("Warning parsing dublincore catalog: " + e.getMessage());
      super.warning(e);
    }
  }
}