/**
 *  Copyright 2009 The Regents of the University of California
 *  Licensed under the Educational Community License, Version 2.0
 *  (the "License"); you may not use this file except in compliance
 *  with the License. You may obtain a copy of the License at
 *
 *  http://www.osedu.org/licenses/ECL-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an "AS IS"
 *  BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 *  or implied. See the License for the specific language governing
 *  permissions and limitations under the License.
 *
 */
package org.opencastproject.util.doc;


import java.util.ArrayList;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Vector;

/**
 * This is the document model class which holds the data about a set of rest endpoints, build this one time and reuse it
 * whenever you need to generate rest documentation
 */
public class DocRestData extends DocData {

  public static final String TEMPLATE_DEFAULT = "/org/opencastproject/templates/rest/template.xhtml";

  protected static RestEndpointHolder writeHolder = new RestEndpointHolder(RestEndpoint.Type.WRITE.name(), "Write");
  protected static RestEndpointHolder readHolder = new RestEndpointHolder(RestEndpoint.Type.READ.name(), "Read");

  protected List<RestEndpointHolder> holders;

  /**
   * Create the base data object for creating REST documents
   * 
   * @param name
   *          the name of the set of rest enpoints (must be alphanumeric (includes _) and no spaces or special chars)
   * @param title
   *          [OPTIONAL] the title of the document
   * @param url
   *          this is the absolute base URL for this endpoint, do not include the trailing slash (e.g. /workflow/rest)
   * @param notes
   *          [OPTIONAL] an array of notes to add into the end of the doc
   */
  public DocRestData(String name, String title, String url, String[] notes) {
    super(name, title, notes);
    if (url == null || "".equals(url)) {
      throw new IllegalArgumentException("url cannot be blank");
    }
    this.meta.put("url", url);
    // create the endpoint holders
    this.holders = new Vector<RestEndpointHolder>(2);
    this.holders.add(DocRestData.readHolder.duplicate());
    this.holders.add(DocRestData.writeHolder.duplicate());
  }

  @Override
  public Map<String, Object> toMap() {
    LinkedHashMap<String, Object> m = new LinkedHashMap<String, Object>();
    m.put("meta", this.meta);
    m.put("notes", this.notes);
    // only pass through the holders with things in them
    ArrayList<RestEndpointHolder> holdersList = new ArrayList<RestEndpointHolder>();
    for (RestEndpointHolder holder : this.holders) {
      if (!holder.getEndpoints().isEmpty()) {
        for (RestEndpoint endpoint : holder.getEndpoints()) {
          // handle the forms
          if (endpoint.getForm() != null) {
            RestTestForm form = endpoint.getForm();
            if (form.isAutoGenerated()) {
              // autogenerate the test form
              form = new RestTestForm(endpoint);
              endpoint.setTestForm(form); // replace
            }
            if (form.isEmpty()) {
              // clear the form if there is no data to test
              endpoint.setTestForm(null);
            }
          }
        }
        holdersList.add(holder);
      }
    }
    m.put("endpointHolders", holdersList);
    return m;
  }

  @Override
  public String getDefaultTemplatePath() {
    return TEMPLATE_DEFAULT;
  }

  @Override
  public String toString() {
    return "DOC:meta="+meta+", notes="+notes+", "+holders;
  }

  public void addEndpoint(RestEndpoint.Type type, RestEndpoint endpoint) {
    if (type == null || endpoint == null) {
      throw new IllegalArgumentException("type and endpoint must not be null");
    }
    RestEndpointHolder currentHolder = null;
    for (RestEndpointHolder holder : this.holders) {
      if (type.name().equals(holder.getName())) {
        currentHolder = holder;
        break;
      }
    }
    if (currentHolder == null) {
      throw new IllegalStateException("Could not find holder of type: " + type.name());
    }
    currentHolder.addEndPoint(endpoint);
  }

  public static boolean isValidPath(String path) {
    boolean valid = true;
    if (isBlank(path)) {
      valid = false;
    } else {
      if (!path.matches("^[\\w\\/{}]+$")) {
        valid = false;
      }
    }
    return valid;
  }

}
