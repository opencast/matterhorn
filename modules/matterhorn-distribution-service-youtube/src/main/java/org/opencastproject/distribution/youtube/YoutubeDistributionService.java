/**
 *  Copyright 2009, 2010 The Regents of the University of California
 *  Licensed under the Educational Community License, Version 2.0
 *  (the "License"); you may not use this file except in compliance
 *  with the License. You may obtain a copy of the License at
 *
 *  http://www.osedu.org/licenses/ECL-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an "AS IS"
 *  BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 *  or implied. See the License for the specific language governing
 *  permissions and limitations under the License.
 *
 */
package org.opencastproject.distribution.youtube;

import org.opencastproject.deliver.schedule.Schedule;
import org.opencastproject.deliver.schedule.Task;
import org.opencastproject.deliver.youtube.YouTubeConfiguration;
import org.opencastproject.deliver.youtube.YouTubeDeliveryAction;
import org.opencastproject.deliver.youtube.YouTubeRemoveAction;
import org.opencastproject.distribution.api.DistributionException;
import org.opencastproject.distribution.api.DistributionService;
import org.opencastproject.mediapackage.MediaPackageElement;
import org.opencastproject.mediapackage.MediaPackageElementBuilderFactory;
import org.opencastproject.remote.api.Job;
import org.opencastproject.remote.api.RemoteServiceManager;
import org.opencastproject.remote.api.Job.Status;
import org.opencastproject.workspace.api.Workspace;

import org.apache.commons.lang.StringUtils;
import org.osgi.service.component.ComponentContext;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.File;
import java.net.URI;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;

/**
 * Distributes media to a Youtube play list.
 */
public class YoutubeDistributionService implements DistributionService {

  /** Receipt type */
  public static final String JOB_TYPE = "org.opencastproject.distribution.youtube";

  /** logger instance */
  private static final Logger logger = LoggerFactory.getLogger(YoutubeDistributionService.class);

  /** workspace instance */
  protected Workspace workspace = null;

  /** The remote service registry */
  protected RemoteServiceManager remoteServiceManager = null;

  /** Youtube configuration instance */
  private static YouTubeConfiguration config = null;

  /** playlist ID */
  private static String destination = null;

  /** URL for uploading */
  private static final String uploadURL = "http://uploads.gdata.youtube.com/feeds/api/users/default/uploads";

  /** category of the video - default to "Education" */
  private static final String category = "Education";

  /** prefix of the URL generated by gdata API */
  private static final String gdataURLPrefix = "http://gdata.youtube.com/feeds/api/users/utubedelivery/uploads/";

  /** prefix of the Youtube URL */
  private static final String youtubeURLPrefix = "http://www.youtube.com/watch?v=";

  /** only one scheduler instance for this service */
  private static Schedule schedule = null;

  /** context strategy for the distribution service */
  YoutubeDistributionContextStrategy contextStrategy = null;

  /** The executor service used to queue and run jobs */
  private ExecutorService executor = null;

  /**
   * Called when service activates. Defined in OSGi resource file.
   */
  public void activate(ComponentContext cc) {
    String username = cc.getBundleContext().getProperty("youtube.username"); // "utubedelivery"
    String password = cc.getBundleContext().getProperty("youtube.password"); // "utubedelivery"
    String clientid = cc.getBundleContext().getProperty("youtube.clientid"); // "abcde"
    String developerkey = cc.getBundleContext().getProperty("youtube.developerkey");
    // "AI39si7bx2AbnOM6RM8J7mdrljfZCzisYzDkqvIqEjV3zjbqQIr6-u_bg3R0MLAVVXLqKjSsxu4ReytWFn7ylIlDk6OC7pdXpQ"

    config = YouTubeConfiguration.getInstance();
    // client ID may not be necessary
    config.setClientId(clientid);
    config.setDeveloperKey(developerkey);
    config.setUploadUrl(uploadURL);
    config.setUserId(username);
    config.setPassword(password);
    config.setCategory(category);

    // create context strategy
    contextStrategy = new YoutubeDistributionContextStrategy();
    // default destination
    destination = cc.getBundleContext().getProperty("youtube.playlist"); // "B8B47104C2C1663B"

    // create the scheduler using file system store
    String directory_name = cc.getBundleContext().getProperty("youtube.task");
    if (directory_name == null || directory_name.equals("")) {
      directory_name = "/tmp/youtube";
    }
    logger.info("Task file directory: {}", directory_name);
    File data_directory = new File(directory_name);
    data_directory.mkdirs();
    schedule = new Schedule(data_directory);
    
    int threads = 1;
    String threadsConfig = StringUtils.trimToNull(cc.getBundleContext().getProperty(
            "org.opencastproject.distribution.youtube.threads"));
    if (threadsConfig != null) {
      try {
        threads = Integer.parseInt(threadsConfig);
      } catch (NumberFormatException e) {
        logger.warn("Youtube distribution threads configuration is malformed: '{}'", threadsConfig);
      }
    }
    executor = Executors.newFixedThreadPool(threads);
  }

  /**
   * Called when service deactivates. Defined in OSGi resource file.
   */
  public void deactivate() {
    // shutdown the scheduler
    schedule.shutdown();
    executor.shutdown();
  }

  /**
   * Gets task name given the media package ID and the track ID.
   * 
   * @param mediaPackge
   *          ID of the package
   * @param track
   *          ID of the track
   * @return task identifier
   */
  private String getTaskID(String mediaPackage, String track) {
    // use "YOUTUBE" + media package identifier + track identifier as task identifier
    return "YOUTUBE-" + mediaPackage.replaceAll("\\.", "-") + "-" + track;
  }

  /**
   * Removes the media delivered by the given task.
   * 
   * @param name
   *          task identifier
   */
  private void remove(String name) throws DistributionException {
    logger.info("Publish task: {}", name);

    YouTubeRemoveAction ract = new YouTubeRemoveAction();
    ract.setName(name + "_r");
    ract.setPublishTask(name);
    schedule.start(ract);

    while (true) {
      Task rTask = schedule.getTask(name + "_r");
      synchronized (rTask) {
        Task.State state = rTask.getState();
        if (state == Task.State.INITIAL || state == Task.State.ACTIVE) {
          try {
            Thread.sleep(1000L);
          } catch (Exception e) {
            throw new RuntimeException(e);
          }
          // still running
          continue;
        } else if (state == Task.State.COMPLETE) {
          logger.info("Succeeded retracting media");
          break;
        } else if (state == Task.State.FAILED) {
          // fail to remove
          throw new DistributionException("Failed to remove media");
        }
      } // end of synchronized
    } // end of schedule loop
  }

  /**
   * {@inheritDoc}
   * 
   * @see org.opencastproject.distribution.api.DistributionService#distribute(String, MediaPackageElement, boolean)
   */
  @Override
  public Job distribute(final String mediaPackageId, final MediaPackageElement element, boolean block)
          throws DistributionException {

    final RemoteServiceManager rs = remoteServiceManager;
    final Job receipt = rs.createJob(JOB_TYPE);

    Runnable command = new Runnable() {
      public void run() {
        receipt.setStatus(Status.RUNNING);
        rs.updateJob(receipt);

        try {

          File sourceFile = workspace.get(element.getURI());
          if (!sourceFile.exists() || !sourceFile.isFile()) {
            throw new IllegalStateException("Could not retrieve a file for element " + element.getIdentifier());
          }

          // get task name
          String name = getTaskID(mediaPackageId, element.getIdentifier());

          // check if the file has already been delivered
          Task savedTask = schedule.getSavedTask(name);

          if (savedTask != null && savedTask.getState() == Task.State.COMPLETE) {
            // has been successfully delivered
            // remove the media
            remove(name);
          }

          YouTubeDeliveryAction act = new YouTubeDeliveryAction();
          act.setName(name);
          act.setTitle(sourceFile.getName());
          // CHNAGE ME: set metadata elements here
          act.setTags(new String[] { "whatever" });
          act.setAbstract("Opencast Distribution Service - Youtube");
          act.setMediaPath(sourceFile.getAbsolutePath());

          // get playlist ID from context strategy
          String contextDestination = contextStrategy.getContextName(mediaPackageId);
          if (contextDestination != null) {
            // use the destination from context strategy
            destination = contextDestination;
          }

          // deliver to a play list
          act.setDestination(destination); // FIXME: replace this with a playlist based on the episode's series

          logger.info("Delivering from {}", sourceFile.getAbsolutePath());

          // start the scheduler
          schedule.start(act);

          while (true) {
            Task task = schedule.getTask(name);
            synchronized (task) {
              Task.State state = task.getState();
              if (state == Task.State.INITIAL || state == Task.State.ACTIVE) {
                try {
                  Thread.sleep(1000L);
                } catch (Exception e) {
                  throw new RuntimeException(e);
                }
                // still running
                continue;
              } else if (state == Task.State.COMPLETE) {
                logger.info("Succeeded delivering from {}", sourceFile.getAbsolutePath());
                String videoURL = act.getEntryUrl();
                // convert the entry URL to a user-oriented URL
                videoURL = videoURL.replace("?client=" + config.getClientId(), "");
                videoURL = videoURL.replace(gdataURLPrefix, youtubeURLPrefix);
                URI newTrackUri = new URI(videoURL);
                MediaPackageElement newElement = MediaPackageElementBuilderFactory.newInstance().newElementBuilder()
                        .elementFromURI(newTrackUri, element.getElementType(), element.getFlavor());
                newElement.setIdentifier(element.getIdentifier() + "-dist");

                receipt.setElement(newElement);
                receipt.setStatus(Status.FINISHED);
                remoteServiceManager.updateJob(receipt);

                break;
              } else if (state == Task.State.FAILED) {
                receipt.setStatus(Status.FAILED);
                remoteServiceManager.updateJob(receipt);
                logger.warn("Failed delivering from {}", sourceFile.getAbsolutePath());
                break;
              }
            }
          } // end of schedule loop

        } catch (Exception e) {
          receipt.setStatus(Status.FAILED);
          remoteServiceManager.updateJob(receipt);
          throw new DistributionException(e);
        }
      }
    };

    Future<?> future = executor.submit(command);
    if (block) {
      try {
        future.get();
      } catch (Exception e) {
        receipt.setStatus(Status.FAILED);
        remoteServiceManager.updateJob(receipt);
        throw new DistributionException(e);
      }
    }

    return receipt;
  }

  /**
   * {@inheritDoc}
   * 
   * @see org.opencastproject.distribution.api.DistributionService#retract(java.lang.String, boolean)
   */
  @Override
  public Job retract(String mediaPackageId, boolean block) throws DistributionException {
    throw new UnsupportedOperationException();
  }

  /**
   * Callback for the OSGi environment to set the workspace reference.
   * 
   * @param workspace
   *          the workspace
   */
  public void setWorkspace(Workspace workspace) {
    this.workspace = workspace;
  }

  /**
   * Callback for the OSGi environment to set the service registry reference.
   * 
   * @param remoteServiceManager
   *          the service registry
   */
  public void setRemoteServiceManager(RemoteServiceManager remoteServiceManager) {
    this.remoteServiceManager = remoteServiceManager;
  }

  /**
   * {@inheritDoc}
   * 
   * @see org.opencastproject.remote.api.JobProducer#getJob(java.lang.String)
   */
  public Job getJob(String id) {
    return remoteServiceManager.getJob(id);
  }

  /**
   * {@inheritDoc}
   * 
   * @see org.opencastproject.remote.api.JobProducer#countJobs(org.opencastproject.remote.api.Job.Status)
   */
  public long countJobs(Status status) {
    if (status == null)
      throw new IllegalArgumentException("status must not be null");
    return remoteServiceManager.count(JOB_TYPE, status);
  }

  /**
   * {@inheritDoc}
   * 
   * @see org.opencastproject.remote.api.JobProducer#countJobs(org.opencastproject.remote.api.Job.Status,
   *      java.lang.String)
   */
  public long countJobs(Status status, String host) {
    if (status == null)
      throw new IllegalArgumentException("status must not be null");
    if (host == null)
      throw new IllegalArgumentException("host must not be null");
    return remoteServiceManager.count(JOB_TYPE, status, host);
  }

}
